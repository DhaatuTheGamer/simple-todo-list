<!DOCTYPE html>
<html lang="en" class=""> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo List v4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base font --- */
        body { font-family: 'Inter', sans-serif; }

        /* --- Theme Variables (Light/Dark) --- */
        :root {
            --bg-primary: #f9fafb; 
            --bg-secondary: #ffffff; 
            --bg-tertiary: #ffffff; 
            --bg-tertiary-hover: #f9fafb; 
            --bg-input: #ffffff; 
            --bg-button: #3b82f6; 
            --bg-button-hover: #2563eb; 
            --bg-button-danger: #ef4444; 
            --bg-button-danger-hover: #dc2626; 
            --bg-button-success: #22c55e; 
            --bg-button-success-hover: #16a34a; 
            --text-primary: #1f2937; 
            --text-secondary: #6b7280; 
            --text-tertiary: #9ca3af; 
            --text-completed: #9ca3af; 
            --text-on-button: #ffffff; 
            --text-link: #3b82f6; 
            --text-link-hover: #2563eb; 
            --border-primary: #f3f4f6; 
            --border-secondary: #e5e7eb; 
            --border-focus: #3b82f6; 
            --border-drag-over: #3b82f6; 
            --icon-default: #9ca3af; 
            --icon-hover-delete: #ef4444; 
            --icon-star-active: #f59e0b; 
            --icon-check: #ffffff; 
            --shadow-color: rgba(0, 0, 0, 0.06); 
            --shadow-color-hover: rgba(0, 0, 0, 0.1);
            --modal-overlay-bg: rgba(0, 0, 0, 0.4);
            --gradient-start: #3b82f6; 
            --gradient-end: #60a5fa; 
        }

        html.dark {
            --bg-primary: #111827; 
            --bg-secondary: #1f2937; 
            --bg-tertiary: #1f2937; 
            --bg-tertiary-hover: #374151; 
            --bg-input: #374151; 
            --bg-button: #2563eb; 
            --bg-button-hover: #1d4ed8; 
            --bg-button-danger: #dc2626; 
            --bg-button-danger-hover: #b91c1c; 
            --bg-button-success: #16a34a; 
            --bg-button-success-hover: #15803d; 
            --text-primary: #f3f4f6; 
            --text-secondary: #9ca3af; 
            --text-tertiary: #6b7280; 
            --text-completed: #6b7280; 
            --text-on-button: #ffffff; 
            --text-link: #60a5fa; 
            --text-link-hover: #93c5fd; 
            --border-primary: #374151; 
            --border-secondary: #4b5563; 
            --border-focus: #60a5fa; 
            --border-drag-over: #60a5fa; 
            --icon-default: #6b7280; 
            --icon-hover-delete: #f87171; 
            --icon-star-active: #fcd34d; 
            --icon-check: #ffffff; 
            --shadow-color: rgba(0, 0, 0, 0.25); 
            --shadow-color-hover: rgba(0, 0, 0, 0.35);
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
            --gradient-start: #2563eb; 
            --gradient-end: #3b82f6; 
        }

        /* --- Apply theme variables --- */
        body { background-color: var(--bg-primary); color: var(--text-primary); transition: background-color 0.3s ease, color 0.3s ease; }
        .bg-main-container { background-color: var(--bg-secondary); }
        .bg-list-item { background-color: var(--bg-tertiary); }
        .hover\:bg-list-item-hover:hover { background-color: var(--bg-tertiary-hover); }
        .text-main { color: var(--text-primary); }
        .text-placeholder { color: var(--text-secondary); }
        .text-meta { color: var(--text-tertiary); }
        .border-divider { border-color: var(--border-primary); }
        .border-input { border-color: var(--border-secondary); }
        .focus-visible\:border-focus:focus-visible { border-color: var(--border-focus); }
        .focus-visible\:ring-focus:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--border-focus); }
        .shadow-main { box-shadow: 0 6px 15px -3px var(--shadow-color); }
        .modal-overlay { background-color: var(--modal-overlay-bg); }
        .modal-content { background-color: var(--bg-secondary); }

        /* --- Button Styles --- */
        .btn {
            padding: 0.65rem 1.25rem; border-radius: 0.5rem; font-weight: 500; color: var(--text-on-button);
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease;
            cursor: pointer; box-shadow: 0 1px 2px 0 var(--shadow-color);
        }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 3px 6px -1px var(--shadow-color-hover); }
        .btn:active { transform: scale(0.98); box-shadow: 0 1px 1px 0 var(--shadow-color); }
        .btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--border-focus); }
        .btn-primary { background-image: linear-gradient(to right, var(--gradient-start), var(--gradient-end)); }
        .btn-primary:hover { background-image: linear-gradient(to right, var(--gradient-start), var(--gradient-end)); filter: brightness(1.1); }
        .btn-danger { background-color: var(--bg-button-danger); }
        .btn-danger:hover { background-color: var(--bg-button-danger-hover); }
        .btn-success { background-color: var(--bg-button-success); }
        .btn-success:hover { background-color: var(--bg-button-success-hover); }
        .btn-text { background: none; border: none; padding: 0.25rem 0.5rem; margin: 0; font-weight: 500; cursor: pointer; color: var(--text-link); transition: color 0.2s ease, background-color 0.2s ease; border-radius: 0.375rem; }
        .btn-text:hover { color: var(--text-link-hover); background-color: rgba(0,0,0,0.05); }
        html.dark .btn-text:hover { background-color: rgba(255,255,255,0.08); }
        .btn-text:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--border-focus); }

        /* --- Input field --- */
        #todoInput { background-color: var(--bg-input); transition: border-color 0.2s ease, box-shadow 0.2s ease; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }
        #todoInput:focus-visible { border-color: var(--border-focus); box-shadow: inset 0 1px 2px rgba(0,0,0,0.05), 0 0 0 2px var(--border-focus); outline: none; }
        #todoDueDateInput, #todoPriorityInput, #searchInput, #sortSelect {
             background-color: var(--bg-input);
             color: var(--text-primary);
             border-color: var(--border-secondary);
        }
        html.dark .recurrence-options-panel select, /* For main add form's recurrence */
        html.dark .edit-recurrence-panel select {  /* For edit mode's recurrence */
            background-color: var(--bg-input);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary); /* Ensure consistent border */
            /* Add some padding if needed, though Tailwind classes usually handle this */
            padding: 0.5rem; /* Tailwind 'p-2' equivalent, adjust as needed */
        }
        #todoDueDateInput:focus-visible, #todoPriorityInput:focus-visible, #searchInput:focus-visible, #sortSelect:focus-visible {
            border-color: var(--border-focus);
            box-shadow: 0 0 0 1px var(--border-focus);
        }


        /* --- Task Item --- */
        #todoList { border: 1px solid var(--border-primary); border-radius: 0.75rem; overflow: hidden; }
        #todoList li {
            /* cursor: grab; /* Set dynamically in JS based on sort order and level */
            transition: background-color 0.2s ease, opacity 0.4s ease, transform 0.4s ease, box-shadow 0.2s ease; 
            will-change: opacity, transform;
            border-bottom: 1px solid var(--border-primary);
        }
        #todoList li:last-child { border-bottom: none; }
        #todoList li button, #todoList li .checkbox-icon, #todoList li input { cursor: pointer; } 
        #todoList li.completed { cursor: default; } 
        #todoList li.editing { cursor: default; } 
        #todoList li.adding { animation: fadeIn 0.5s ease forwards; }
        #todoList li.deleting { animation: fadeOutSlide 0.5s ease forwards; }

        /* --- Drag & Drop --- */
        #todoList li.dragging {
            opacity: 0.5; background-color: var(--bg-tertiary-hover);
            box-shadow: 0 4px 8px var(--shadow-color-hover); cursor: grabbing; 
            border-color: transparent; 
        }
        #todoList li.drag-over-top { border-top: 2px solid var(--border-drag-over); }
        #todoList li.drag-over-bottom { border-bottom: 2px solid var(--border-drag-over); }

        /* --- Task Text --- */
        .todo-text { font-weight: 500; cursor: pointer; transition: color 0.3s ease; }
        #todoList li.completed span.todo-text { text-decoration: line-through; color: var(--text-completed); opacity: 0.8; font-weight: 400; cursor: default; }
        #todoList li.completed .checkbox-icon { background-color: var(--border-focus); border-color: var(--border-focus); transform: scale(1.1); }
        #todoList li.completed .checkbox-icon svg { transform: scale(1); opacity: 1; }

        /* --- Edit Input --- */
        .edit-input { /* Text input for editing */
            flex-grow: 1; border: 1px solid var(--border-secondary); border-radius: 0.375rem; padding: 0.5rem; margin: 0.25rem 0.25rem 0.25rem 0; /* Adjusted margin */ 
            color: var(--text-primary); background-color: var(--bg-input); outline: none; 
            line-height: inherit; height: auto; 
        }
        .edit-due-date-input, .edit-priority-select, .edit-recurrence-type-select { /* Specific styles for date/priority/recurrence in edit mode */
            border: 1px solid var(--border-secondary); border-radius: 0.375rem; padding: 0.5rem; margin: 0.25rem; 
            color: var(--text-primary); background-color: var(--bg-input); outline: none; 
            line-height: inherit; height: auto; font-size: 0.875rem; /* Smaller font for these inputs */
            flex-grow: 0; 
            min-width: 120px; 
        }
        .edit-input:focus-visible, .edit-due-date-input:focus-visible, .edit-priority-select:focus-visible, .edit-recurrence-type-select:focus-visible {
            border-color: var(--border-focus); box-shadow: 0 0 0 1px var(--border-focus); /* Subtle focus */
        }
        /* Container for edit inputs within the list item */
        .edit-controls-wrapper {
            display: flex; flex-wrap: wrap; align-items: center; width: 100%; padding-left: 2.5rem; /* Align with where text usually starts */
        }
        .edit-recurrence-panel { /* Panel for recurrence options in edit mode */
            width: 100%; 
            padding: 0.5rem; margin-top: 0.5rem;
            border: 1px solid var(--border-secondary); border-radius: 0.375rem;
            background-color: var(--bg-tertiary-hover); /* Slightly different bg */
        }
        .recurrence-options-panel { /* General styles for recurrence panels */
            padding: 0.75rem; margin-top: 0.5rem; border-radius: 0.5rem;
            border: 1px solid var(--border-secondary);
            background-color: var(--bg-tertiary-hover);
        }
        .recurrence-options-panel label, .recurrence-options-panel select, .recurrence-options-panel input {
            font-size: 0.875rem; margin-right: 0.5rem;
        }
        .recurrence-days-of-week { margin-top: 0.5rem; }
        .recurrence-days-of-week input[type="checkbox"] { margin-right: 0.25rem; }


        /* --- Checkbox --- */
        .checkbox-icon { width: 1.25rem; height: 1.25rem; border: 2px solid var(--border-secondary); border-radius: 50%; margin-right: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease; }
        .checkbox-icon:hover { border-color: var(--border-focus); }
        .checkbox-icon svg { width: 0.75rem; height: 0.75rem; fill: var(--icon-check); transition: transform 0.2s ease, opacity 0.2s ease; transform: scale(0.5); opacity: 0; }

        /* --- Star icon --- */
        .star-btn { transition: transform 0.2s ease; }
        .star-btn svg { fill: var(--icon-default); transition: fill 0.2s ease, transform 0.2s ease; }
        .star-btn:hover svg { fill: var(--icon-star-active); transform: scale(1.2); }
        .star-btn:active { transform: scale(0.9); }
        #todoList li.starred .star-btn svg { fill: var(--icon-star-active); animation: starPulse 0.4s ease; }
        .star-btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-tertiary), 0 0 0 4px var(--icon-star-active); }

        /* --- Priority Indicators --- */
        #todoList li.priority-low { border-left: 5px solid #22c55e; /* Tailwind green-500 */ }
        #todoList li.priority-medium { border-left: 5px solid #f59e0b; /* Tailwind amber-500 */ }
        #todoList li.priority-high { border-left: 5px solid #ef4444; /* Tailwind red-500 */ }
        #todoList li.priority-low:hover { background-color: var(--bg-tertiary-hover); border-left-color: #16a34a; }
        #todoList li.priority-medium:hover { background-color: var(--bg-tertiary-hover); border-left-color: #d97706; }
        #todoList li.priority-high:hover { background-color: var(--bg-tertiary-hover); border-left-color: #dc2626; }


        /* --- Delete icon --- */
        .delete-btn { transition: transform 0.2s ease; }
        .delete-btn svg { fill: var(--icon-default); transition: fill 0.2s ease; }
        .delete-btn:hover svg { fill: var(--icon-hover-delete); transform: scale(1.1); }
        .delete-btn:active { transform: scale(0.9); }
        .delete-btn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-tertiary), 0 0 0 4px var(--icon-hover-delete); }

        /* --- Animations --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeOutSlide { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(-20px); } }
        @keyframes starPulse { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-3px, 0, 0); } 40%, 60% { transform: translate3d(3px, 0, 0); } }
        .shake-input { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; border-color: var(--bg-button-danger) !important; }

        /* --- Modal --- */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s linear; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s 0s linear; }
        .modal-content { padding: 1.5rem; border-radius: 0.75rem; max-width: 90%; width: 24rem; text-align: center; transform: scale(0.95); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; box-shadow: var(--shadow-main); } 
        .modal-overlay.visible .modal-content { transform: scale(1); opacity: 1; }

        /* --- Sidebar --- */
        #sidebar { width: 250px; transition: transform 0.3s ease-in-out; transform: translateX(0); flex-shrink: 0; height: 100vh; position: fixed; top: 0; left: 0; z-index: 40; background-color: var(--bg-secondary); border-right: 1px solid var(--border-primary); box-shadow: 2px 0 5px rgba(0,0,0,0.05); }
        #sidebar.collapsed { transform: translateX(-100%); }
        #mainContent { transition: margin-left 0.3s ease-in-out; margin-left: 250px; width: calc(100% - 250px); padding: 2rem; }
        #mainContent.sidebar-collapsed { margin-left: 0; width: 100%; }
        .sidebar-link { transition: background-color 0.2s ease, color 0.2s ease, border-left-color 0.2s ease; border-left: 3px solid transparent; }
        .sidebar-link.active { background-color: var(--bg-tertiary-hover); color: var(--text-primary); font-weight: 600; border-left-color: var(--border-focus); }
        .sidebar-link:not(.active) { color: var(--text-secondary); }
        .sidebar-link:not(.active):hover { color: var(--text-primary); }
        .sidebar-link:focus-visible { outline: none; background-color: var(--bg-tertiary-hover); box-shadow: inset 0 0 0 2px var(--border-focus); }

        /* --- Theme Toggle --- */
        #themeToggleBtn { position: relative; overflow: hidden; width: 2.5rem; height: 2.5rem; }
        #themeToggleBtn svg { transition: transform 0.4s ease, opacity 0.4s ease; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(0deg); opacity: 1; }
        #themeToggleBtn svg.icon-hidden { opacity: 0; pointer-events: none; }
        #themeToggleBtn .icon-sun.icon-hidden { transform: translate(-50%, -150%) rotate(-90deg); }
        #themeToggleBtn .icon-moon.icon-hidden { transform: translate(-50%, 50%) rotate(90deg); }
        #themeToggleBtn:focus-visible { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--border-focus); }

        /* --- Empty State --- */
        .empty-state-container { text-align: center; padding: 3rem 1rem; opacity: 0.6; transition: opacity 0.3s ease; }
        .empty-state-container svg { width: 100px; height: 100px; margin: 0 auto 1.5rem; } 
        .empty-state-container p { color: var(--text-secondary); font-size: 1rem; }

        /* --- Utility --- */
        .hidden { display: none !important; }

        /* --- Body scroll --- */
        html, body { min-height: 100vh; }
        body::-webkit-scrollbar { display: none; } 
        body { -ms-overflow-style: none; scrollbar-width: none; } 

    </style>
</head>
<body class="overflow-x-hidden"> 
    <aside id="sidebar" class="p-4 flex flex-col">
        <h2 class="text-xl font-semibold mb-6 text-main px-3">Filters</h2>
        <nav class="flex-grow">
            <ul>
                <li><button data-filter="all" class="sidebar-link w-full text-left p-3 rounded-r-md hover:bg-tertiary-hover flex items-center active"><svg class="w-5 h-5 mr-3 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 4H21V6H3V4ZM3 11H21V13H3V11ZM3 18H21V20H3V18Z"></path></svg>All Tasks</button></li>
                <li><button data-filter="starred" class="sidebar-link w-full text-left p-3 rounded-r-md hover:bg-tertiary-hover flex items-center"><svg class="w-5 h-5 mr-3 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21L16.54 13.97L22 9.24L14.81 8.63L12 2L9.19 8.63L2 9.24L7.46 13.97L5.82 21L12 17.27Z"></path></svg>Starred</button></li>
                <li><button data-filter="active" class="sidebar-link w-full text-left p-3 rounded-r-md hover:bg-tertiary-hover flex items-center"><svg class="w-5 h-5 mr-3 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C17.52 2 22 6.48 22 12C22 17.52 17.52 22 12 22C6.48 22 2 17.52 2 12C2 6.48 6.48 2 12 2ZM12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4Z"></path></svg>Active</button></li>
                <li><button data-filter="completed" class="sidebar-link w-full text-left p-3 rounded-r-md hover:bg-tertiary-hover flex items-center"><svg class="w-5 h-5 mr-3 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-2.29-5.71l-1.42-1.41L10 14.17l4.29-4.29 1.41 1.41L10 17l-2.29-2.71z"></path></svg>Completed</button></li>
            </ul>
        </nav>
        <div class="mt-auto p-3 text-sm text-meta" id="sidebarTaskCount"></div>
    </aside>

    <div id="mainContent">
        <header class="flex justify-between items-center mb-8">
            <button id="sidebarToggleBtn" class="p-2 rounded-md hover:bg-tertiary-hover focus-visible:ring-focus" aria-label="Toggle Sidebar">
                <svg class="w-6 h-6 text-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 4H21V6H3V4ZM3 11H21V13H3V11ZM3 18H21V20H3V18Z"></path></svg>
            </button>
            <button id="themeToggleBtn" class="p-2 rounded-full hover:bg-tertiary-hover flex items-center justify-center focus-visible:ring-focus" aria-label="Toggle Theme">
                <svg id="themeIconSun" class="icon-sun w-6 h-6 text-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 9c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3zm0 8c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zM1 11h2c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1zm19.99 0h2c.55 0 1 .45 1 1s-.45 1-1 1h-2c-.55 0-1-.45-1-1s.45-1 1-1zM11 1v2c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1s-1 .45-1 1zm0 19.99v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 4.22l1.41 1.41c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L4.22 5.64c-.39-.39-.39-1.02 0-1.41.39-.39 1.03-.39 1.42 0zm12.73 12.73l1.41 1.41c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0l-1.41-1.41c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0zm1.41-12.73l-1.41 1.41c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41l1.41-1.41c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41zm-12.73 12.73l-1.41 1.41c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41l1.41-1.41c.39-.39.39 1.02 0 1.41.39.39 1.02.39 1.41 0z"></path></svg>
                <svg id="themeIconMoon" class="icon-moon w-6 h-6 text-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm-1.1 14.41c-2.98-.53-5.31-3.11-5.31-6.14 0-3.45 2.8-6.25 6.25-6.25.3 0 .59.02.88.07-3.45.91-6.07 4.06-6.07 7.76 0 1.95.72 3.73 1.9 5.11-.47-.1-.92-.25-1.35-.45z"></path></svg>
            </button>
        </header>

        <div class="w-full max-w-2xl mx-auto bg-main-container rounded-xl shadow-main p-6 md:p-8">
            <h1 class="text-3xl font-bold mb-2 text-center text-main">My Todo List</h1>
            <p id="taskCount" class="text-center text-meta text-sm mb-6">Loading tasks...</p>

            <!-- Search and Sort Controls -->
            <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-2">
                <input type="search" id="searchInput" placeholder="Search tasks..." class="w-full md:w-3/5 border border-input rounded-lg p-2.5 text-sm text-main bg-input focus:outline-none focus-visible:border-focus focus-visible:ring-focus transition duration-150 placeholder-placeholder">
                <select id="sortSelect" class="w-full md:w-2/5 border border-input rounded-lg p-2.5 text-sm text-main bg-input focus:outline-none focus-visible:border-focus focus-visible:ring-focus transition duration-150">
                    <option value="default">Order: Default</option>
                    <option value="dueDateAsc">Due Date (Oldest First)</option>
                    <option value="dueDateDesc">Due Date (Newest First)</option>
                    <option value="priorityDesc">Priority (High to Low)</option>
                    <option value="priorityAsc">Priority (Low to High)</option>
                    <option value="nameAZ">Name (A-Z)</option>
                    <option value="nameZA">Name (Z-A)</option>
                </select>
            </div>
            
            <!-- Add Task Form -->
            <div class="mb-6"> 
                <div class="flex flex-col sm:flex-row gap-1.5 shadow-sm rounded-lg"> 
                    <input type="text" id="todoInput" class="flex-grow border border-input rounded-lg sm:rounded-l-lg sm:rounded-r-none p-2.5 text-sm text-main bg-input focus:outline-none focus-visible:border-focus focus-visible:ring-focus transition duration-150 placeholder-placeholder" placeholder="Add a new task..." aria-label="Add a new task">
                    <input type="date" id="todoDueDateInput" title="Due Date" class="border border-input rounded-lg sm:rounded-none p-2.5 text-xs text-main bg-input focus:outline-none focus-visible:border-focus focus-visible:ring-focus transition duration-150 w-full sm:w-auto" style="min-width: 130px;">
                    <select id="todoPriorityInput" title="Priority" class="border border-input rounded-lg sm:rounded-none p-2.5 text-xs text-main bg-input focus:outline-none focus-visible:border-focus focus-visible:ring-focus transition duration-150 w-full sm:w-auto" style="min-width: 90px;">
                        <option value="1">Low</option>
                        <option value="2" selected>Medium</option>
                        <option value="3">High</option>
                    </select>
                    <button type="button" id="setRecurrenceBtnMain" class="btn-text text-xs p-2.5 border border-input rounded-lg sm:rounded-none w-full sm:w-auto" title="Set Recurrence">Recurrence</button>
                    <button id="addTodoBtn" class="btn btn-primary rounded-lg sm:rounded-r-lg sm:rounded-l-none px-4 py-2.5 w-full sm:w-auto text-sm">Add</button> 
                </div>
                <div id="mainRecurrenceOptions" class="recurrence-options-panel hidden mt-2">
                     {/* Recurrence options will be built here by JS */}
                </div>
            </div>
            <p id="inputError" class="text-red-500 text-sm -mt-2 mb-4 hidden">Task cannot be empty!</p> 
            
            <div id="listContainer">
                <ul id="todoList" class=""></ul>
                <div id="clearCompletedContainer" class="text-right mt-4 hidden"><button id="clearCompletedBtn" class="btn-text">Clear Completed Tasks</button></div>
                <div id="emptyListMessage" class="empty-state-container hidden"><svg class="w-[100px] h-[100px] mx-auto mb-6 text-secondary" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.79,11.15,12.8,2.16a1.67,1.67,0,0,0-2.36,0L1.45,11.15a1.5,1.5,0,0,0-.09,2.12l.09.09,8.79,9a1.8,1.8,0,0,0,2.54,0l9-9,.09-.09A1.5,1.5,0,0,0,21.79,11.15ZM12.05,19.5,4.8,12.25,11.3,5.76a.67.67,0,0,1,.94,0l6.5,6.49Z M10.38,11.42a1,1,0,0,0,1.41,0l4-4a1,1,0,0,0-1.41-1.41L11.09,9.3,9.71,7.91a1,1,0,0,0-1.41,1.41Z"/></svg><p>No tasks here yet. Add one above!</p></div>
                <div id="emptyFilterMessage" class="empty-state-container hidden">
                    <svg class="w-[100px] h-[100px] mx-auto mb-6 text-secondary" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                      <path d="M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z"/>
                    </svg>
                    <p>No tasks match the current filter.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <p class="text-main text-lg mb-6">This will permanently delete the task. Are you sure?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmDeleteBtn" class="btn btn-success">Sure</button>
                <button id="cancelDeleteBtn" class="btn btn-danger">Nope</button>
            </div>
        </div>
    </div>

    <div id="clearConfirmationModal" class="modal-overlay">
        <div class="modal-content">
            <p class="text-main text-lg mb-6">Delete all completed tasks permanently?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmClearBtn" class="btn btn-success">Yes, Clear</button>
                <button id="cancelClearBtn" class="btn btn-danger">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const todoInput = document.getElementById('todoInput');
        const addTodoBtn = document.getElementById('addTodoBtn');
        const todoList = document.getElementById('todoList'); 
        const emptyListMessage = document.getElementById('emptyListMessage');
        const emptyFilterMessage = document.getElementById('emptyFilterMessage');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('mainContent');
        const sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        const themeIconSun = document.getElementById('themeIconSun');
        const themeIconMoon = document.getElementById('themeIconMoon');
        const filterButtons = document.querySelectorAll('.sidebar-link'); 
        const inputError = document.getElementById('inputError');
        const taskCountElement = document.getElementById('taskCount');
        const sidebarTaskCountElement = document.getElementById('sidebarTaskCount');
        const clearCompletedBtn = document.getElementById('clearCompletedBtn');
        const clearCompletedContainer = document.getElementById('clearCompletedContainer');
        const clearConfirmationModal = document.getElementById('clearConfirmationModal');
        const confirmClearBtn = document.getElementById('confirmClearBtn');
        const cancelClearBtn = document.getElementById('cancelClearBtn');
        
        // --- App State ---
        let todoIdToDelete = null; 
        let currentFilter = 'all'; 
        let currentSearchTerm = ''; 
        let currentSortOrder = 'default'; 
        let currentParentIdForNewTask = null; 
        let isSidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true'; 
        let currentlyEditing = null; 
        let draggedItem = null; 

        // --- Event Listeners (Initial Setup) ---
        addTodoBtn.addEventListener('click', addTodo); 
        todoInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTodo(); else clearInputError(); }); 
        
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
           searchInput.addEventListener('input', handleSearchInput);
        }
        const sortSelect = document.getElementById('sortSelect');
        if (sortSelect) {
           sortSelect.addEventListener('change', handleSortChange);
        }
        const setRecurrenceBtnMain = document.getElementById('setRecurrenceBtnMain');
        if (setRecurrenceBtnMain) {
            setRecurrenceBtnMain.addEventListener('click', () => toggleRecurrencePanel('mainRecurrenceOptions', null));
        }


        todoList.addEventListener('click', handleListClick); 
        todoList.addEventListener('dblclick', handleListDoubleClick); 
        document.addEventListener('DOMContentLoaded', initializeApp); 
        confirmDeleteBtn.addEventListener('click', handleConfirmDelete); 
        cancelDeleteBtn.addEventListener('click', handleCancelDelete); 
        confirmationModal.addEventListener('click', (e) => e.target === confirmationModal && handleCancelDelete()); 
        clearCompletedBtn.addEventListener('click', showClearConfirmationModal); 
        confirmClearBtn.addEventListener('click', handleConfirmClear); 
        cancelClearBtn.addEventListener('click', hideClearConfirmationModal); 
        clearConfirmationModal.addEventListener('click', (e) => e.target === clearConfirmationModal && hideClearConfirmationModal()); 
        document.addEventListener('keydown', handleGlobalKeyDown); 
        sidebarToggleBtn.addEventListener('click', toggleSidebar); 
        filterButtons.forEach(button => button.addEventListener('click', handleFilterClick)); 
        themeToggleBtn.addEventListener('click', toggleTheme); 

        // --- Drag & Drop Event Listeners ---
        todoList.addEventListener('dragstart', handleDragStart);     
        todoList.addEventListener('dragend', handleDragEnd);         
        todoList.addEventListener('dragover', handleDragOver);       
        todoList.addEventListener('dragenter', handleDragEnter);     
        todoList.addEventListener('dragleave', handleDragLeave);     
        todoList.addEventListener('drop', handleDrop);               


        // --- Initialization ---
        function initializeApp() {
            loadTheme(); 
            applyInitialSidebarState(); 
            loadTodos(); 
        }

        // --- Core Functions ---
        function addTodo() {
            const todoText = todoInput.value.trim(); 
            if (todoText === '') { 
                showInputError("Task cannot be empty!"); 
                return; 
            }
            clearInputError(); 
            const dueDateInput = document.getElementById('todoDueDateInput'); 
            const dueDateValue = dueDateInput ? dueDateInput.value : null;

            const priorityInput = document.getElementById('todoPriorityInput');
            const priorityValue = priorityInput ? parseInt(priorityInput.value, 10) : 2; 
            
            let parentId = null;
            let level = 0;

            if (currentParentIdForNewTask !== null) {
                parentId = Number(currentParentIdForNewTask);
                const parentTask = getTodosFromStorage().find(t => t.id === parentId);
                if (parentTask) {
                    level = parentTask.level + 1;
                } else {
                    console.error("Parent task not found for sub-task creation. Defaulting to top-level.");
                    parentId = null; 
                }
            }
            
            const recurrenceData = collectRecurrenceData('main');

            const todo = { 
                text: todoText, 
                completed: false, 
                id: Date.now(), 
                starred: false,
                dueDate: dueDateValue || null, 
                priority: isNaN(priorityValue) || ![1,2,3].includes(priorityValue) ? 2 : priorityValue,
                parentId: parentId,
                level: level,
                recurrence: recurrenceData 
            };
            const todos = getTodosFromStorage();
            todos.unshift(todo); 
            saveTodosToStorage(todos);
            
            if (currentParentIdForNewTask !== null) {
                currentParentIdForNewTask = null; 
                todoInput.placeholder = "Add a new task..."; 
            }
            document.getElementById('mainRecurrenceOptions').classList.add('hidden'); // Hide after add

            loadTodos(); 
            
            todoInput.value = ''; 
            if(dueDateInput) dueDateInput.value = ''; 
            if(priorityInput) priorityInput.value = '2'; 
            todoInput.focus(); 
        }

        function renderTodoItem(todo) {
            const li = document.createElement('li');
            li.classList.add('flex', 'items-center', 'bg-list-item', 'hover:bg-list-item-hover', 'transition', 'p-0'); 
            li.dataset.id = todo.id;
            li.dataset.starred = todo.starred;
            li.dataset.completed = todo.completed;
            li.dataset.priority = todo.priority; 
            li.dataset.level = todo.level || 0; 
            li.setAttribute('aria-level', (todo.level || 0) + 1);
            li.style.marginLeft = `${(todo.level || 0) * 25}px`; 

            if (todo.priority === 1) li.classList.add('priority-low');
            else if (todo.priority === 3) li.classList.add('priority-high');
            else li.classList.add('priority-medium'); 
            
            li.draggable = currentSortOrder === 'default' && !todo.completed && (todo.level || 0) === 0;
            li.style.cursor = (li.draggable) ? 'grab' : 'default';

            if (todo.completed) li.classList.add('completed'); 
            if (todo.starred) li.classList.add('starred');

            const contentWrapper = document.createElement('div');
            contentWrapper.classList.add('flex', 'items-center', 'flex-grow', 'min-w-0', 'py-3', 'pl-4', 'pr-2'); 
            const checkbox = document.createElement('div');
            checkbox.classList.add('checkbox-icon');
            checkbox.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
            checkbox.dataset.action = 'toggleComplete'; 
            checkbox.setAttribute('role', 'checkbox'); checkbox.setAttribute('aria-checked', todo.completed); checkbox.setAttribute('aria-label', 'Mark task as complete');
            const textSpan = document.createElement('span');
            textSpan.textContent = todo.text;
            textSpan.classList.add('todo-text', 'flex-grow', 'text-main', 'mx-3', 'min-w-0', 'truncate'); 
            
            contentWrapper.appendChild(checkbox); 
            contentWrapper.appendChild(textSpan); 

            if (todo.dueDate) {
                const dueDateSpan = document.createElement('span');
                dueDateSpan.classList.add('task-due-date', 'text-xs', 'text-meta', 'ml-2', 'whitespace-nowrap', 'pl-1', 'pr-1'); 
                dueDateSpan.textContent = `Due: ${todo.dueDate}`; 
                contentWrapper.appendChild(dueDateSpan); 
            }
             // Display recurrence info if present
            const recurrenceSummary = getRecurrenceSummary(todo.recurrence);
            if (recurrenceSummary) {
                const recurrenceSpan = document.createElement('span');
                recurrenceSpan.classList.add('task-recurrence-info', 'text-xs', 'text-blue-500', 'dark:text-blue-400', 'ml-2', 'whitespace-nowrap', 'pl-1', 'pr-1', 'italic');
                recurrenceSpan.textContent = recurrenceSummary;
                contentWrapper.appendChild(recurrenceSpan);
            }

            const buttonWrapper = document.createElement('div');
            buttonWrapper.classList.add('flex', 'items-center', 'flex-shrink-0', 'pr-3', 'py-3'); 
            const starBtn = document.createElement('button');
            starBtn.classList.add('star-btn', 'p-1', 'rounded-full'); 
            starBtn.dataset.action = 'star'; 
            starBtn.innerHTML = `<svg class="w-5 h-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21L16.54 13.97L22 9.24L14.81 8.63L12 2L9.19 8.63L2 9.24L7.46 13.97L5.82 21L12 17.27Z"></path></svg>`;
            starBtn.setAttribute('aria-label', todo.starred ? 'Unstar task' : 'Star task'); starBtn.setAttribute('aria-pressed', todo.starred);
            
            const MAX_SUBTASK_LEVEL = 2; 
            if ((todo.level || 0) < MAX_SUBTASK_LEVEL) {
                const addSubtaskBtn = document.createElement('button');
                addSubtaskBtn.classList.add('add-subtask-btn', 'ml-2', 'p-1', 'rounded-full', 'hover:bg-gray-200', 'dark:hover:bg-gray-700');
                addSubtaskBtn.title = "Add sub-task";
                addSubtaskBtn.dataset.action = 'addSubtask';
                addSubtaskBtn.dataset.parentId = todo.id;
                addSubtaskBtn.innerHTML = `<svg class="w-5 h-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>`;
                buttonWrapper.appendChild(addSubtaskBtn); 
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-btn', 'ml-2', 'p-1', 'rounded-full'); 
            deleteBtn.dataset.action = 'delete'; 
            deleteBtn.innerHTML = `<svg class="w-5 h-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>`;
            deleteBtn.setAttribute('aria-label', 'Delete task');
            
            buttonWrapper.appendChild(starBtn); 
            buttonWrapper.appendChild(deleteBtn);

            li.appendChild(contentWrapper); li.appendChild(buttonWrapper);
            todoList.appendChild(li); 
        }

        // --- Event Handlers ---
        function handleListClick(event) {
            if (currentlyEditing !== null) return; 
            const target = event.target; 
            const li = target.closest('li[data-id]'); 
            if (!li) return; 
            const todoId = Number(li.dataset.id); 
            const actionTarget = target.closest('[data-action]'); 
            if (actionTarget) {
                const action = actionTarget.dataset.action; 
                if (action === 'delete') showConfirmationModal(todoId); 
                else if (action === 'star') toggleStar(todoId, li, actionTarget); 
                else if (action === 'toggleComplete') toggleComplete(todoId, li, actionTarget); 
                else if (action === 'addSubtask') {
                    const parentId = actionTarget.dataset.parentId;
                    currentParentIdForNewTask = parentId;
                    const parentTask = getTodosFromStorage().find(t => t.id === Number(parentId));
                    const parentText = parentTask ? parentTask.text : '';
                    todoInput.placeholder = `Adding sub-task to: "${parentText.substring(0,20)}${parentText.length > 20 ? '...' : ''}"`;
                    todoInput.focus();
                }
            } 
        }
        
        function handleListDoubleClick(event) {
            const target = event.target;
            if (target.classList.contains('todo-text') && !target.closest('li.completed')) {
                const li = target.closest('li[data-id]');
                if (li && currentlyEditing === null) { 
                    enterEditMode(li, target, Number(li.dataset.id)); 
                }
            }
        }
        
        function handleGlobalKeyDown(event) {
             if (event.key === 'Escape') {
                 if (confirmationModal.classList.contains('visible')) handleCancelDelete(); 
                 if (clearConfirmationModal.classList.contains('visible')) hideClearConfirmationModal(); 
                 if (currentlyEditing !== null) { 
                    const li = todoList.querySelector(`li[data-id="${currentlyEditing}"]`);
                    const textEditInput = li?.querySelector('.edit-input'); 
                    if(li && textEditInput) saveEdit(li, textEditInput, currentlyEditing, true); 
                 }
             }
        }

        // --- Edit Mode ---
        function enterEditMode(li, textSpan, todoId) {
            currentlyEditing = todoId; li.classList.add('editing'); li.draggable = false; li.style.cursor = 'default'; 
            
            const taskDataForEdit = getTodosFromStorage().find(t => t.id === todoId);
            
            const originalTextSpan = li.querySelector('.todo-text'); 
            const actionButtons = li.querySelector('.flex-shrink-0'); 
            if(originalTextSpan) originalTextSpan.classList.add('hidden');
            if(actionButtons) actionButtons.classList.add('hidden');

            const editWrapper = document.createElement('div');
            editWrapper.classList.add('edit-controls-wrapper'); 

            const textEditInput = document.createElement('input');
            textEditInput.type = 'text';
            textEditInput.value = originalTextSpan.textContent;
            textEditInput.classList.add('edit-input'); 

            const editDueDateInput = document.createElement('input');
            editDueDateInput.type = 'date';
            editDueDateInput.id = 'editDueDateInput'; 
            editDueDateInput.classList.add('edit-due-date-input'); 
            if (taskDataForEdit && taskDataForEdit.dueDate) editDueDateInput.value = taskDataForEdit.dueDate;
            
            const editPriorityInput = document.createElement('select');
            editPriorityInput.id = 'editPriorityInput';
            editPriorityInput.classList.add('edit-priority-select'); 
            const priorities = [{value: 1, text: 'Low'}, {value: 2, text: 'Medium'}, {value: 3, text: 'High'}];
            priorities.forEach(p => {
                const option = document.createElement('option');
                option.value = p.value; option.textContent = p.text;
                if (taskDataForEdit && taskDataForEdit.priority === p.value) option.selected = true;
                editPriorityInput.appendChild(option);
            });

            const setRecurrenceBtnEdit = document.createElement('button');
            setRecurrenceBtnEdit.type = 'button';
            setRecurrenceBtnEdit.textContent = 'Set Recurrence';
            setRecurrenceBtnEdit.classList.add('btn-text', 'text-xs', 'ml-auto'); 
            const editRecurrencePanelId = `editRecurrenceOptions_${todoId}`;
            setRecurrenceBtnEdit.onclick = () => toggleRecurrencePanel(editRecurrencePanelId, todoId);

            editWrapper.appendChild(textEditInput); 
            editWrapper.appendChild(editDueDateInput);
            editWrapper.appendChild(editPriorityInput);
            editWrapper.appendChild(setRecurrenceBtnEdit); 
            
            const editRecurrencePanel = document.createElement('div');
            editRecurrencePanel.id = editRecurrencePanelId;
            editRecurrencePanel.classList.add('edit-recurrence-panel', 'hidden', 'w-full'); 
            editWrapper.appendChild(editRecurrencePanel); 

            const checkbox = li.querySelector('.checkbox-icon'); 
            checkbox.after(editWrapper);

            textEditInput.focus(); textEditInput.select(); 
            
            const saveOnBlurOrEnter = (event) => {
                const targetIsInsideEditWrapper = editWrapper.contains(event.relatedTarget);
                const targetIsRecurrencePanelItself = event.relatedTarget && event.relatedTarget.closest('.edit-recurrence-panel, .recurrence-options-panel');

                if (event.type === 'blur' && (targetIsInsideEditWrapper || targetIsRecurrencePanelItself)) {
                    return; 
                }
                document.removeEventListener('click', outsideClickListener, true); 
                textEditInput.removeEventListener('blur', saveOnBlurOrEnter);
                editDueDateInput.removeEventListener('blur', saveOnBlurOrEnter);
                editPriorityInput.removeEventListener('blur', saveOnBlurOrEnter);
                saveEdit(li, textEditInput, todoId, false); 
            };
            
            const outsideClickListener = (event) => {
                if (!li.contains(event.target) && !event.target.closest('.modal-overlay')) { 
                    saveOnBlurOrEnter(event); 
                }
            };
            setTimeout(() => {
                document.addEventListener('click', outsideClickListener, true); 
            }, 0);
            
            textEditInput.addEventListener('blur', saveOnBlurOrEnter);
            editDueDateInput.addEventListener('blur', saveOnBlurOrEnter);
            editPriorityInput.addEventListener('blur', saveOnBlurOrEnter);

            textEditInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); saveOnBlurOrEnter(e); } 
                else if (e.key === 'Escape') { saveEdit(li, textEditInput, todoId, true); } 
            });
            editDueDateInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') saveEdit(li, textEditInput, todoId, true); });
            editPriorityInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') saveEdit(li, textEditInput, todoId, true); });
        }

        function saveEdit(li, textInput, todoId, isCancelled) { 
             if (currentlyEditing !== todoId && !isCancelled) return; 

             const textSpanToUnhide = li.querySelector('.todo-text'); 
             const actionButtonsToUnhide = li.querySelector('.flex-shrink-0'); 
            
             const editWrapper = li.querySelector('.edit-controls-wrapper');
             const editDueDateInput = editWrapper ? editWrapper.querySelector('#editDueDateInput') : null;
             const editPriorityInput = editWrapper ? editWrapper.querySelector('#editPriorityInput') : null;

             const newText = textInput.value.trim(); 
             const newDueDate = editDueDateInput ? (editDueDateInput.value || null) : null;
             let newPriority = editPriorityInput ? parseInt(editPriorityInput.value, 10) : null;
            
             if (newPriority !== null && (isNaN(newPriority) || ![1,2,3].includes(newPriority))) {
               newPriority = null; 
             }
            
             const editRecurrencePanelId = `editRecurrenceOptions_${todoId}`;
             const newRecurrence = getRecurrenceDataFromPanel(editRecurrencePanelId);

            if(editWrapper) editWrapper.remove();

            if(textSpanToUnhide) textSpanToUnhide.classList.remove('hidden'); 
            if(actionButtonsToUnhide) actionButtonsToUnhide.classList.remove('hidden');
            li.classList.remove('editing');

            const isCompleted = li.classList.contains('completed');
            li.draggable = currentSortOrder === 'default' && !isCompleted && (parseInt(li.dataset.level) || 0) === 0; 
            li.style.cursor = (li.draggable) ? 'grab' : 'default';
            currentlyEditing = null; 
            document.removeEventListener('click', outsideClickListener, true); 

            if (isCancelled) return;

            const originalTaskData = getTodosFromStorage().find(t => t.id === todoId);
            if (!originalTaskData) { console.error("Original task data not found for saving edit."); return; }

            const updatedProperties = {};
            let hasChanges = false;

            if (newText !== '' && newText !== originalTaskData.text) {
                updatedProperties.text = newText;
                hasChanges = true;
            } else if (newText === '' && originalTaskData.text !== '') {
                if(textSpanToUnhide) textSpanToUnhide.textContent = originalTaskData.text; 
                return; 
            }

            if (newDueDate !== originalTaskData.dueDate) {
               updatedProperties.dueDate = newDueDate;
               hasChanges = true;
            }
            if (newPriority !== null && newPriority !== originalTaskData.priority) {
               updatedProperties.priority = newPriority;
               hasChanges = true;
            }
            if (JSON.stringify(newRecurrence) !== JSON.stringify(originalTaskData.recurrence)) {
                updatedProperties.recurrence = newRecurrence;
                hasChanges = true;
            }


            if (hasChanges) {
                if (updatedProperties.text !== undefined && textSpanToUnhide) {
                   textSpanToUnhide.textContent = updatedProperties.text;
                }
                
                let dueDateSpan = li.querySelector('.task-due-date');
                if (updatedProperties.dueDate !== undefined) { 
                    if (updatedProperties.dueDate) { 
                        if (!dueDateSpan) { 
                            dueDateSpan = document.createElement('span');
                            dueDateSpan.classList.add('task-due-date', 'text-xs', 'text-meta', 'ml-2', 'whitespace-nowrap', 'pl-1', 'pr-1');
                            if(textSpanToUnhide) textSpanToUnhide.after(dueDateSpan); 
                            else if(li.querySelector('.checkbox-icon')) li.querySelector('.checkbox-icon').after(dueDateSpan); 
                        }
                        dueDateSpan.textContent = `Due: ${updatedProperties.dueDate}`;
                    } else if (dueDateSpan) { 
                        dueDateSpan.remove();
                    }
                }
                
                if (updatedProperties.priority !== undefined) {
                   li.dataset.priority = updatedProperties.priority;
                   li.classList.remove('priority-low', 'priority-medium', 'priority-high');
                   if (updatedProperties.priority === 1) li.classList.add('priority-low');
                   else if (updatedProperties.priority === 3) li.classList.add('priority-high');
                   else li.classList.add('priority-medium');
                }
                // Visual update for recurrence change on the task item itself
                let recurrenceSpan = li.querySelector('.task-recurrence-info');
                if (updatedProperties.recurrence !== undefined) {
                    const summary = getRecurrenceSummary(updatedProperties.recurrence);
                    if (summary) {
                        if (!recurrenceSpan) {
                            recurrenceSpan = document.createElement('span');
                            recurrenceSpan.classList.add('task-recurrence-info', 'text-xs', 'text-blue-500', 'dark:text-blue-400', 'ml-2', 'italic');
                            (dueDateSpan || textSpanToUnhide || li.querySelector('.checkbox-icon')).after(recurrenceSpan);
                        }
                        recurrenceSpan.textContent = summary;
                    } else if (recurrenceSpan) {
                        recurrenceSpan.remove();
                    }
                }
                updateTodoInStorage(todoId, updatedProperties); 
            }
        }


        // --- Action Handlers ---
        function toggleComplete(todoId, li, checkbox) {
            const isCompleted = !li.classList.contains('completed'); 
            li.classList.toggle('completed', isCompleted); li.dataset.completed = isCompleted; checkbox.setAttribute('aria-checked', isCompleted); 
            li.draggable = currentSortOrder === 'default' && !isCompleted && (parseInt(li.dataset.level) || 0) === 0; 
            li.style.cursor = (li.draggable) ? 'grab' : 'default';
            
            if(isCompleted && li.classList.contains('editing')) { 
                 const textEditInput = li.querySelector('.edit-input');
                 if(textEditInput) saveEdit(li, textEditInput, todoId, true); 
            }
            
            // Recurrence Logic for completing a task
            if (isCompleted) {
                let todos = getTodosFromStorage(); // Get a mutable copy of all todos
                const currentTaskIndex = todos.findIndex(t => t.id === todoId);
                if (currentTaskIndex === -1) {
                    console.error("Task to complete not found in storage.");
                    return; // Should not happen
                }
                const currentTask = { ...todos[currentTaskIndex] }; // Work with a copy of the current task

                if (currentTask.recurrence && currentTask.recurrence.type !== 'none' && currentTask.dueDate) {
                    const nextInstanceDueDate = calculateNextDueDate(currentTask.dueDate, currentTask.recurrence);
                    
                    if (nextInstanceDueDate) {
                        const nextInstanceTodo = {
                            ...currentTask, // text, priority, parentId, level, etc.
                            id: Date.now(), 
                            completed: false, 
                            dueDate: nextInstanceDueDate, 
                            recurrence: JSON.parse(JSON.stringify(currentTask.recurrence)), 
                            starred: false 
                        };
                        
                        todos[currentTaskIndex] = { ...currentTask, completed: true, recurrence: null };
                        todos.push(nextInstanceTodo);
                        
                        saveTodosToStorage(todos); 
                        loadTodos(); 
                        return; 
                    } else {
                        todos[currentTaskIndex] = { ...currentTask, completed: true, recurrence: null };
                        saveTodosToStorage(todos);
                    }
                } else {
                    todos[currentTaskIndex] = { ...currentTask, completed: true };
                    saveTodosToStorage(todos);
                }
            } else {
                updateTodoInStorage(todoId, { completed: false });
            }
            
            applyFiltersAndSearch(); 
            updateTaskCount(); 
            updateClearButtonVisibility(); 
        }

        function toggleStar(todoId, li, starBtn) {
            const isStarred = !li.classList.contains('starred'); 
            li.classList.toggle('starred', isStarred); li.dataset.starred = isStarred; 
            starBtn.setAttribute('aria-label', isStarred ? 'Unstar task' : 'Star task'); starBtn.setAttribute('aria-pressed', isStarred); 
            updateTodoInStorage(todoId, { starred: isStarred });
            applyFiltersAndSearch(); 
        }

        function deleteTodo(todoId) {
            const liToDelete = todoList.querySelector(`li[data-id="${todoId}"]`);
            if (liToDelete) {
                liToDelete.classList.add('deleting');
                liToDelete.addEventListener('animationend', () => {
                    liToDelete.remove();
                    let todos = getTodosFromStorage();
                    const idsToDelete = [todoId];
                    function collectChildren(parentId) {
                        const children = todos.filter(t => t.parentId === parentId);
                        children.forEach(child => {
                            idsToDelete.push(child.id);
                            collectChildren(child.id); 
                        });
                    }
                    collectChildren(todoId);
                    
                    todos = todos.filter(todo => !idsToDelete.includes(todo.id));
                    saveTodosToStorage(todos);
                    loadTodos(); 
                }, { once: true });
            } else {
                 console.warn("Delete failed: Element not found visually:", todoId);
                 const todos = getTodosFromStorage().filter(todo => todo.id !== todoId); 
                 saveTodosToStorage(todos);
                 loadTodos();
            }
        }

        // --- Input Error Handling ---
        function showInputError(message) {
            inputError.textContent = message; inputError.classList.remove('hidden'); 
            todoInput.classList.add('shake-input', 'border-red-500'); 
            todoInput.addEventListener('animationend', () => todoInput.classList.remove('shake-input'), { once: true });
        }
        function clearInputError() { 
            inputError.classList.add('hidden'); todoInput.classList.remove('border-red-500'); 
        }

        // --- Modals ---
        function showConfirmationModal(todoId) { todoIdToDelete = todoId; confirmationModal.classList.add('visible'); cancelDeleteBtn.focus(); }
        function hideConfirmationModal() { todoIdToDelete = null; confirmationModal.classList.remove('visible'); }
        function handleConfirmDelete() { if (todoIdToDelete !== null) { deleteTodo(todoIdToDelete); } hideConfirmationModal(); }
        function handleCancelDelete() { hideConfirmationModal(); }
        function showClearConfirmationModal() { clearConfirmationModal.classList.add('visible'); cancelClearBtn.focus(); }
        function hideClearConfirmationModal() { clearConfirmationModal.classList.remove('visible'); }
        function handleConfirmClear() {
            const todos = getTodosFromStorage();
            const completedTodos = todos.filter(todo => todo.completed);
            const activeTodos = todos.filter(todo => !todo.completed); 
            if (completedTodos.length > 0) {
                completedTodos.forEach(todo => {
                    const li = todoList.querySelector(`li[data-id="${todo.id}"]`);
                    if (li) { li.classList.add('deleting'); li.addEventListener('animationend', () => li.remove(), { once: true }); }
                });
                setTimeout(() => { 
                    saveTodosToStorage(activeTodos); 
                    loadTodos();
                }, 50); 
            }
            hideClearConfirmationModal(); 
        }
        function updateClearButtonVisibility() { 
            const hasCompleted = getTodosFromStorage().some(todo => todo.completed); 
            clearCompletedContainer.classList.toggle('hidden', !hasCompleted); 
        }

        // --- Filtering, Searching & Sorting ---
        function handleSearchInput(event) {
            currentSearchTerm = event.target.value.toLowerCase();
            applyFiltersAndSearch();
        }

        function handleSortChange(event) {
            currentSortOrder = event.target.value;
            loadTodos(); 
        }

        function handleFilterClick(event) {
            if (currentlyEditing !== null) { 
                const li = todoList.querySelector(`li[data-id="${currentlyEditing}"]`); 
                const textEditInput = li?.querySelector('.edit-input');
                if (li && textEditInput) { saveEdit(li, textEditInput, currentlyEditing, false); } 
            }
            const selectedFilter = event.currentTarget.dataset.filter; 
            if (selectedFilter === currentFilter) return; 
            currentFilter = selectedFilter; 
            filterButtons.forEach(button => button.classList.toggle('active', button.dataset.filter === currentFilter));
            applyFiltersAndSearch();
        }

        function applyFiltersAndSearch() { 
            const listItems = todoList.querySelectorAll('li'); 
            const searchTerm = currentSearchTerm; 

            listItems.forEach(li => {
                const taskText = li.querySelector('.todo-text')?.textContent.toLowerCase() || '';
                const isStarred = li.dataset.starred === 'true'; 
                const isCompleted = li.dataset.completed === 'true'; 
                
                let matchesFilter = true; 
                switch (currentFilter) {
                    case 'starred': matchesFilter = isStarred; break; 
                    case 'active': matchesFilter = !isCompleted; break; 
                    case 'completed': matchesFilter = isCompleted; break; 
                    case 'all': default: matchesFilter = true; break;
                }

                const matchesSearch = searchTerm === '' || taskText.includes(searchTerm);
                
                li.classList.toggle('hidden', !(matchesFilter && matchesSearch)); 
            });
            updateEmptyMessageVisibility(); 
        }

        // --- Task Count ---
        function updateTaskCount() {
            const todos = getTodosFromStorage(); 
            const activeTasks = todos.filter(todo => !todo.completed).length; 
            const totalTasks = todos.length;
            let countText = '';
            if (activeTasks === 0 && totalTasks > 0) { countText = 'All tasks completed!'; } 
            else if (activeTasks === 1) { countText = '1 active task'; } 
            else { countText = `${activeTasks} active tasks`; }
            taskCountElement.textContent = countText; 
            sidebarTaskCountElement.textContent = `${activeTasks} active`;
        }

        // --- Empty Messages ---
        function updateEmptyMessageVisibility() {
            const allTodos = getTodosFromStorage(); 
            const visibleItems = todoList.querySelectorAll('li:not(.hidden)'); 
            const isListEmpty = allTodos.length === 0; 
            
            const hasActiveSearch = currentSearchTerm !== '';
            const noResultsForSearch = hasActiveSearch && visibleItems.length === 0 && !isListEmpty;
            const noResultsForFilter = !hasActiveSearch && currentFilter !== 'all' && visibleItems.length === 0 && !isListEmpty;

            emptyListMessage.classList.toggle('hidden', !isListEmpty); 
            
            const filterTextElement = emptyFilterMessage.querySelector('p');
            if (noResultsForSearch) {
                filterTextElement.textContent = `No tasks match your search for "${currentSearchTerm}".`;
                emptyFilterMessage.classList.remove('hidden');
            } else if (noResultsForFilter) {
                 switch(currentFilter) {
                    case 'starred': filterTextElement.textContent = 'No starred tasks.'; break; 
                    case 'active': filterTextElement.textContent = 'No active tasks.'; break; 
                    case 'completed': filterTextElement.textContent = 'No completed tasks.'; break; 
                    default: filterTextElement.textContent = 'No tasks match the current filter.';  
                }
                emptyFilterMessage.classList.remove('hidden');
            } else {
                emptyFilterMessage.classList.add('hidden');
            }
            
            todoList.classList.toggle('hidden', isListEmpty || noResultsForSearch || noResultsForFilter);

            if (isListEmpty) { 
                clearCompletedContainer.classList.add('hidden'); 
            } else {
                 updateClearButtonVisibility(); 
            }
        }

        // --- Sidebar ---
        function applyInitialSidebarState() { 
            sidebar.classList.toggle('collapsed', isSidebarCollapsed); 
            mainContent.classList.toggle('sidebar-collapsed', isSidebarCollapsed); 
        }
        function toggleSidebar() { 
            isSidebarCollapsed = !isSidebarCollapsed; 
            sidebar.classList.toggle('collapsed', isSidebarCollapsed); 
            mainContent.classList.toggle('sidebar-collapsed', isSidebarCollapsed); 
            localStorage.setItem('sidebarCollapsed', isSidebarCollapsed); 
        }

        // --- Theme ---
        function loadTheme() { 
            const savedTheme = localStorage.getItem('theme') || 'light'; 
            const isDark = savedTheme === 'dark'; 
            document.documentElement.classList.toggle('dark', isDark); 
            themeIconSun.classList.toggle('icon-hidden', isDark); 
            themeIconMoon.classList.toggle('icon-hidden', !isDark); 
        }
        function toggleTheme() { 
            if (currentlyEditing !== null) { 
                const li = todoList.querySelector(`li[data-id="${currentlyEditing}"]`); 
                const textEditInput = li?.querySelector('.edit-input');
                if (li && textEditInput) { saveEdit(li, textEditInput, currentlyEditing, false); } 
            } 
            const isDark = document.documentElement.classList.toggle('dark'); 
            localStorage.setItem('theme', isDark ? 'dark' : 'light'); 
            themeIconSun.classList.toggle('icon-hidden', isDark); 
            themeIconMoon.classList.toggle('icon-hidden', !isDark); 
        }

        // --- Drag & Drop Handlers ---
        function handleDragStart(e) {
            const target = e.target;
            if (currentSortOrder !== 'default' || (parseInt(target.dataset.level) || 0) > 0 || target.classList.contains('completed') || target.classList.contains('editing') || e.target.closest('button, input, .checkbox-icon, .edit-controls-wrapper')) {
                e.preventDefault(); return;
            }
            draggedItem = target; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItem.dataset.id); 
            setTimeout(() => { if(draggedItem) draggedItem.classList.add('dragging'); }, 0);
        }
        function handleDragEnd(e) { if (draggedItem) { draggedItem.classList.remove('dragging'); } clearDragOverIndicators(); draggedItem = null; }
        function handleDragOver(e) {
            e.preventDefault(); e.dataTransfer.dropEffect = 'move'; 
            const targetItem = e.target.closest('li[draggable="true"]'); 
            if (!targetItem || targetItem === draggedItem || (parseInt(targetItem.dataset.level) || 0) > 0) { 
                 clearDragOverIndicators(); return; 
            }
             const rect = targetItem.getBoundingClientRect(); const midpoint = rect.top + rect.height / 2; const isOverTopHalf = e.clientY < midpoint; 
             clearDragOverIndicators(targetItem); 
             if (isOverTopHalf) { targetItem.classList.remove('drag-over-bottom'); targetItem.classList.add('drag-over-top'); } 
             else { targetItem.classList.remove('drag-over-top'); targetItem.classList.add('drag-over-bottom'); }
        }
         function handleDragEnter(e) { /* Optional highlighting */ }
        function handleDragLeave(e) {
            const targetItem = e.target.closest('li');
            if (targetItem && !targetItem.contains(e.relatedTarget)) { targetItem.classList.remove('drag-over-top', 'drag-over-bottom'); }
             if (!e.currentTarget.contains(e.relatedTarget)) { clearDragOverIndicators(); }
        }
        function handleDrop(e) {
            e.preventDefault(); 
            const targetItem = e.target.closest('li[draggable="true"]');
            if (!targetItem || !draggedItem || targetItem === draggedItem || (parseInt(targetItem.dataset.level) || 0) > 0) { 
                clearDragOverIndicators(); return; 
            }
            const dropBefore = targetItem.classList.contains('drag-over-top');
            if (dropBefore) { todoList.insertBefore(draggedItem, targetItem); } 
            else { todoList.insertBefore(draggedItem, targetItem.nextSibling); }
            targetItem.classList.remove('drag-over-top', 'drag-over-bottom');
            if (currentSortOrder === 'default') { 
                updateStorageOrder(); 
            }
        }
        function clearDragOverIndicators(exceptItem = null) { document.querySelectorAll('#todoList li').forEach(li => { if (li !== exceptItem) { li.classList.remove('drag-over-top', 'drag-over-bottom'); } }); }
        
        function updateStorageOrder() { 
            const listItems = Array.from(todoList.querySelectorAll('li'));
            const topLevelItemIds = listItems
                .filter(item => (parseInt(item.dataset.level) || 0) === 0)
                .map(li => Number(li.dataset.id));
            
            const currentTodos = getTodosFromStorage();
            let orderedStorageTodos = [];
            const processedIds = new Set();

            topLevelItemIds.forEach(id => {
                const task = currentTodos.find(t => t.id === id);
                if (task) {
                    orderedStorageTodos.push(task);
                    processedIds.add(id);
                }
            });

            currentTodos.forEach(task => {
                if (!processedIds.has(task.id)) {
                    orderedStorageTodos.push(task);
                }
            });
            
            if (orderedStorageTodos.length === currentTodos.length) { 
                saveTodosToStorage(orderedStorageTodos); 
            } else { 
                console.warn("Storage order update mismatch. Saving currentTodos as fallback.", currentTodos.length, orderedStorageTodos.length);
                saveTodosToStorage(currentTodos); 
            }
        }

        // --- Date Formatting Helper ---
        function formatDateISO(date) { // Ensures date is valid and returns YYYY-MM-DD
            if (!(date instanceof Date) || isNaN(date.getTime())) return null;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // --- Recurrence Logic ---
        function calculateNextDueDate(taskDateStr, recurrenceRule) {
            if (!taskDateStr || !recurrenceRule || !recurrenceRule.type || recurrenceRule.type === 'none') {
                return null;
            }
            const parts = taskDateStr.split('-');
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; 
            const day = parseInt(parts[2], 10);

            if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
            const currentDate = new Date(year, month, day); 
            if (isNaN(currentDate.getTime())) return null;

            let nextDate = new Date(currentDate.getTime()); 

            switch (recurrenceRule.type) {
                case 'daily':
                    nextDate.setDate(currentDate.getDate() + 1);
                    break;
                case 'weekly':
                     // If specific days are set for weekly, find the next occurrence.
                    if (recurrenceRule.daysOfWeek && Array.isArray(recurrenceRule.daysOfWeek) && recurrenceRule.daysOfWeek.length > 0) {
                        const sortedRuleDays = [...recurrenceRule.daysOfWeek].sort((a, b) => a - b);
                        // Start checking from the day AFTER the current due date
                        nextDate.setDate(currentDate.getDate() + 1); 
                        
                        for (let i = 0; i < 7; i++) { // Check next 7 days
                            let dayOfWeek = nextDate.getDay(); // 0 (Sun) - 6 (Sat)
                            if (sortedRuleDays.includes(dayOfWeek)) {
                                return formatDateISO(nextDate);
                            }
                            nextDate.setDate(nextDate.getDate() + 1);
                        }
                        // Fallback if no day found in next 7 days (e.g. rule changed, or date is far in future)
                        // This part of the logic might need refinement if a selected day is >7 days away
                        // For now, it will just find the next valid day in sequence.
                        console.warn("Could not find next weekly day within 7 days. Defaulting to +7 days from original date.");
                        nextDate = new Date(currentDate.getTime()); // Reset to original date
                        nextDate.setDate(currentDate.getDate() + 7); // Fallback to simple +7 days
                    } else { // Fallback if daysOfWeek is not set for weekly (treat as simple +7)
                        nextDate.setDate(currentDate.getDate() + 7);
                    }
                    break;
                case 'monthly':
                    const originalMonthDay = currentDate.getDate();
                    nextDate.setDate(1); 
                    nextDate.setMonth(currentDate.getMonth() + 1); 
                    const daysInNextMonth = new Date(nextDate.getFullYear(), nextDate.getMonth() + 1, 0).getDate();
                    nextDate.setDate(Math.min(originalMonthDay, daysInNextMonth));
                    break;
                case 'specific_days':
                    if (!recurrenceRule.daysOfWeek || !Array.isArray(recurrenceRule.daysOfWeek) || recurrenceRule.daysOfWeek.length === 0) {
                        console.warn("Invalid or empty daysOfWeek for 'specific_days' recurrence.");
                        return null;
                    }
                    const sortedDays = [...recurrenceRule.daysOfWeek].sort((a, b) => a - b);
                    let tempNextDate = new Date(currentDate.getTime()); 
                    
                    for (let i = 0; i < 366 ; i++) { 
                        tempNextDate.setDate(tempNextDate.getDate() + 1); // Increment first
                        const dayOfWeek = tempNextDate.getDay(); 
                        if (sortedDays.includes(dayOfWeek)) {
                            return formatDateISO(tempNextDate);
                        }
                    }
                    console.warn("Could not find next specific day within a year for 'specific_days'.");
                    return null; 
                default:
                    console.warn("Unknown recurrence type:", recurrenceRule.type);
                    return null;
            }
            return formatDateISO(nextDate);
        }


        // --- Recurrence Summary Helper ---
        function getRecurrenceSummary(recurrenceRule) {
            if (!recurrenceRule || recurrenceRule.type === 'none') {
                return '';
            }

            const type = recurrenceRule.type;
            let summary = `Recurs ${type}`;

            if (type === 'weekly' || type === 'specific_days') { // Consolidate for display
                if (recurrenceRule.daysOfWeek && recurrenceRule.daysOfWeek.length > 0) {
                    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    const selectedDayNames = recurrenceRule.daysOfWeek
                        .map(dayIndex => dayNames[dayIndex])
                        .join(', ');
                    summary += ` on ${selectedDayNames}`;
                } else {
                    summary = `Recurs ${type} (no days selected)`; 
                }
            } else if (type === 'monthly') {
                // Future: summary += ` on the ${recurrenceRule.dayOfMonth}${getDaySuffix(recurrenceRule.dayOfMonth)}`;
            }
            return summary;
        }
        /* // Helper for day suffix (e.g., 1st, 2nd, 3rd, 4th) - if needed for monthly
        function getDaySuffix(day) {
            if (day > 3 && day < 21) return 'th';
            switch (day % 10) {
                case 1:  return "st";
                case 2:  return "nd";
                case 3:  return "rd";
                default: return "th";
            }
        }*/


        // --- Task Hierarchy Building ---
        function buildHierarchicalTaskArray(allTasks, parentId = null, level = 0) {
            let result = [];
            const children = allTasks.filter(task => task.parentId === parentId);
            
            if (currentSortOrder !== 'default') {
                 children.sort(sortTasksLogic); 
            }

            children.forEach(task => {
                task.level = level; 
                result.push(task);
                result = result.concat(buildHierarchicalTaskArray(allTasks, task.id, level + 1));
            });
            return result;
        }
        
        function sortTasksLogic(a,b){ 
             switch (currentSortOrder) {
                case 'dueDateAsc': 
                    if (a.dueDate === b.dueDate) return 0; 
                    if (!a.dueDate) return 1; 
                    if (!b.dueDate) return -1;
                    return new Date(a.dueDate) - new Date(b.dueDate);
                case 'dueDateDesc': 
                    if (a.dueDate === b.dueDate) return 0;
                    if (!a.dueDate) return 1;
                    if (!b.dueDate) return -1;
                    return new Date(b.dueDate) - new Date(a.dueDate);
                case 'priorityDesc': 
                    return (b.priority || 0) - (a.priority || 0);
                case 'priorityAsc': 
                    return (a.priority || 0) - (b.priority || 0);
                case 'nameAZ':
                    return a.text.toLowerCase().localeCompare(b.text.toLowerCase());
                case 'nameZA':
                    return b.text.toLowerCase().localeCompare(a.text.toLowerCase());
                default: return 0; 
            }
        }


        // --- Local Storage Functions ---
        function getTodosFromStorage() {
            try {
                const todosString = localStorage.getItem('todos'); 
                const todos = todosString ? JSON.parse(todosString) : []; 
                return todos.map(todo => ({
                    text: todo.text ?? 'Untitled Task', 
                    completed: todo.completed ?? false, 
                    id: todo.id ?? Date.now(), 
                    starred: todo.starred ?? false,
                    dueDate: todo.dueDate ?? null,          
                    priority: todo.priority ?? 2,
                    parentId: todo.parentId ?? null,       
                    level: todo.level ?? 0,
                    recurrence: todo.recurrence ?? null    
                })).filter(todo => todo.id && typeof todo.text === 'string'); 
            } catch (e) { console.error("Error reading todos from localStorage:", e); return []; }
        }

        function saveTodosToStorage(todos) { 
            try { 
                localStorage.setItem('todos', JSON.stringify(todos)); 
            } catch (e) { 
                console.error("Error saving todos to localStorage:", e); 
            } 
        }

        function updateTodoInStorage(todoId, updatedProperties) {
            const todos = getTodosFromStorage(); 
            let found = false;
            const updatedTodos = todos.map(todo => { 
                if (todo.id === todoId) { 
                    found = true; 
                    return { ...todo, ...updatedProperties }; 
                } 
                return todo; 
            });
            if (found) { 
                saveTodosToStorage(updatedTodos); 
            } else { 
                console.warn("Update failed: Todo not found in storage:", todoId); 
            }
        }

        function loadTodos() {
            let allTasks = getTodosFromStorage(); 
            
            if (currentSortOrder !== 'default') {
                allTasks.sort(sortTasksLogic);
            }
            
            const topLevelTasks = allTasks.filter(task => task.parentId === null);
            
            let hierarchicallyOrderedTasks = [];
            topLevelTasks.forEach(topTask => {
                // topTask.level = 0; // Level is set by buildHierarchicalTaskArray starting from root
                hierarchicallyOrderedTasks = hierarchicallyOrderedTasks.concat(
                    buildHierarchicalTaskArray(allTasks, topTask.id, 0, topTask) // Pass topTask itself
                );
            });
            // A slightly different approach for buildHierarchicalTaskArray to include the parent itself
            // Or, more simply:
            hierarchicallyOrderedTasks = buildHierarchicalTaskArray(allTasks, null, 0);


            todoList.innerHTML = ''; 
            hierarchicallyOrderedTasks.forEach(todo => renderTodoItem(todo)); 
            
            applyFiltersAndSearch(); 
            updateTaskCount(); 
            updateClearButtonVisibility(); 
        }

        // --- Recurrence UI Management ---
        function buildRecurrenceFormFields(panelId, recurrenceData = null) {
            const panel = document.getElementById(panelId);
            if (!panel) return;

            panel.innerHTML = `
                <div class="flex items-center mb-2">
                    <label for="${panelId}_type" class="mr-2">Repeats:</label>
                    <select id="${panelId}_type" class="border border-input p-1 rounded text-sm">
                        <option value="none">None</option>
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <!-- <option value="monthly">Monthly</option> -->
                        <option value="specific_days">Specific Days</option> <!-- Added back for UI consistency -->
                    </select>
                </div>
                <div id="${panelId}_daysOfWeek" class="recurrence-days-of-week hidden">
                    <span>On:</span>
                    ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => `
                        <label class="ml-2"><input type="checkbox" name="${panelId}_day" value="${index}"> ${day}</label>
                    `).join('')}
                </div>
                <div class="mt-3 flex justify-end">
                     <button type="button" id="${panelId}_clear" class="btn-text text-xs text-red-500 mr-2">Clear Recurrence</button>
                </div>
            `;

            const typeSelect = panel.querySelector(`#${panelId}_type`);
            const daysOfWeekDiv = panel.querySelector(`#${panelId}_daysOfWeek`);
            
            typeSelect.onchange = () => {
                // Show daysOfWeekDiv if type is 'weekly' OR 'specific_days'
                daysOfWeekDiv.classList.toggle('hidden', !['weekly', 'specific_days'].includes(typeSelect.value));
            };
            
            if (recurrenceData) {
                typeSelect.value = recurrenceData.type || 'none';
                if (['weekly', 'specific_days'].includes(recurrenceData.type)) {
                    if (recurrenceData.daysOfWeek && Array.isArray(recurrenceData.daysOfWeek)) {
                        recurrenceData.daysOfWeek.forEach(dayIndex => {
                            const checkbox = panel.querySelector(`input[name="${panelId}_day"][value="${dayIndex}"]`);
                            if (checkbox) checkbox.checked = true;
                        });
                    }
                }
            }
            typeSelect.onchange(); 

            const clearBtn = panel.querySelector(`#${panelId}_clear`);
            clearBtn.onclick = () => {
                typeSelect.value = 'none';
                panel.querySelectorAll(`input[name="${panelId}_day"]`).forEach(cb => cb.checked = false);
                typeSelect.onchange(); 
                if(panelId.startsWith('editRecurrenceOptions_')) { 
                    const todoId = parseInt(panelId.split('_')[1]);
                    const li = todoList.querySelector(`li[data-id="${todoId}"]`);
                    const textInput = li?.querySelector('.edit-input'); 
                    if (li && textInput) saveEdit(li, textInput, todoId, false);
                }
            };
        }

        function toggleRecurrencePanel(panelId, todoIdForEdit = null) {
            const panel = document.getElementById(panelId);
            if (!panel) return;
            const isHidden = panel.classList.toggle('hidden');
            if (!isHidden) { 
                let taskRecurrenceData = null;
                if (todoIdForEdit !== null) { 
                    const task = getTodosFromStorage().find(t => t.id === todoIdForEdit);
                    taskRecurrenceData = task ? task.recurrence : null;
                }
                buildRecurrenceFormFields(panelId, taskRecurrenceData);
            }
        }

        function getRecurrenceDataFromPanel(panelId) {
            const panel = document.getElementById(panelId);
            if (!panel || panel.classList.contains('hidden')) return null;

            const type = panel.querySelector(`#${panelId}_type`).value;
            if (type === 'none') return null;

            const recurrence = { type: type }; 

            if (type === 'weekly' || type === 'specific_days') { // Collect daysOfWeek for both
                recurrence.daysOfWeek = Array.from(panel.querySelectorAll(`input[name="${panelId}_day"]:checked`))
                                           .map(cb => parseInt(cb.value));
                if(recurrence.daysOfWeek.length === 0) return null; // Requires at least one day if type is weekly/specific
            }
            return recurrence;
        }

        function collectRecurrenceData(sourceType, entityId = null) { 
            if (sourceType === 'main') {
                return getRecurrenceDataFromPanel('mainRecurrenceOptions');
            } else if (sourceType === 'edit' && entityId !== null) {
                return getRecurrenceDataFromPanel(`editRecurrenceOptions_${entityId}`);
            }
            return null;
        }
    </script>

</body>
</html>
